import time, math
from mbot_bridge.api import MBot

SETPOINT = 0.50
MARGIN   = 0.05
V_FWD    = 0.20
V_BACK   = -0.15
DT       = 0.05

bot = MBot()

def _is_number(x):
    try:
        return isinstance(x, (int, float)) and math.isfinite(float(x))
    except Exception:
        return False

def _extract_ranges(scan_obj):
    if scan_obj is None:
        return None
    if isinstance(scan_obj, dict) and "ranges" in scan_obj:
        return scan_obj["ranges"]
    if hasattr(scan_obj, "ranges"):
        return getattr(scan_obj, "ranges")
    if isinstance(scan_obj, (list, tuple)):
        return list(scan_obj)
    if hasattr(scan_obj, "__iter__"):
        try:
            return list(scan_obj)
        except Exception:
            return None
    return None

def _center_distance_from_any_scan(scan_obj):
    ranges = _extract_ranges(scan_obj)
    if not ranges:
        return float("nan")
    mid = len(ranges) // 2
    val = ranges[mid]
    return float(val) if _is_number(val) and val > 0 else float("nan")

def get_front_distance_m():
    for name in ("get_front_distance_m", "get_front_range", "front_distance", "front_range"):
        if hasattr(bot, name):
            try:
                d = getattr(bot, name)()
                return float(d) if _is_number(d) and d > 0 else float("nan")
            except Exception:
                pass
    for name in ("get_lidar_scan", "get_scan", "lidar_scan", "get_laser_scan", "laser_scan",
                 "lidar", "read_lidar", "get_ranges", "ranges"):
        if hasattr(bot, name):
            try:
                candidate = getattr(bot, name)
                scan_obj = candidate() if callable(candidate) else candidate
                d = _center_distance_from_any_scan(scan_obj)
                if math.isfinite(d) and d > 0:
                    return d
            except Exception:
                pass
    return float("nan")

try:
    print("Controller started. Target = %.2fm ± %.2fm" % (SETPOINT, MARGIN))
    lost = 0
    while True:
        d = get_front_distance_m()
        if not math.isfinite(d):
            lost += 1
            bot.stop()
            if lost % int(1/DT) == 0:
                print("No valid distance reading. Stopped (lost=%d)" % lost)
        else:
            lost = 0
            if d > SETPOINT + MARGIN:
                bot.drive(V_FWD, 0.0, 0.0)
                print("Too far (%.2fm) → moving forward" % d)
            elif d < SETPOINT - MARGIN:
                bot.drive(V_BACK, 0.0, 0.0)
                print("Too close (%.2fm) → moving back" % d)
            else:
                bot.stop()
                print("In band (%.2fm) → stop" % d)
        time.sleep(DT)
except KeyboardInterrupt:
    print("KeyboardInterrupt → stopping.")
finally:
    bot.stop()
    print("Stopped safely.")
