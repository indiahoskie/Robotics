import time
import numpy as np
import inspect
from mbot_bridge.api import MBot

# Get distance to wall
def find_fwd_dist(ranges, thetas, window=5):
    """Find the distance to the nearest object in front of the robot.

    Args:
        ranges (list): The ranges from the Lidar scan.
        thetas (list): The angles from the Lidar scan.
        window (int, optional): The window to average ranges over. Defaults to 5.

    Returns:
        float: The distance to the nearest obstacle in front of the robot.
    """
    # Handle empty/bad inputs quickly
    if ranges is None or thetas is None or len(ranges) == 0 or len(thetas) == 0:
        return float('inf')

    # Grab the rays near the front of the scan.
    fwd_ranges = np.array(ranges[:window] + ranges[-window:], dtype=float)
    fwd_thetas = np.array(thetas[:window] + thetas[-window:], dtype=float)

    # Grab just the positive values.
    valid_idx = (fwd_ranges > 0).nonzero()
    if len(valid_idx[0]) == 0:
        return float('inf')

    fwd_ranges = fwd_ranges[valid_idx]
    fwd_thetas = fwd_thetas[valid_idx]

    # Compute forward distances.
    fwd_dists = fwd_ranges * np.cos(fwd_thetas)
    return float(np.mean(fwd_dists))  # Return the mean.

# ---------- Small compatibility helpers (minimal additions) ----------
def safe_read_lidar(bot):
    """
    Try your professor's API first (read_lidar), then a couple common fallbacks.
    Return (ranges, thetas) or None if no data yet.
    """
    # 1) Your original call
    try:
        scan = bot.read_lidar()
        if isinstance(scan, dict):
            ranges = scan.get('range') or scan.get('ranges')
            thetas = scan.get('angle') or scan.get('angles')
            return ranges, thetas
        else:
            return scan  # expected to be (ranges, thetas)
    except Exception as e:
        msg = str(e).lower()
        # If it's just "no data on channel", allow the loop to wait/retry
        if "no data on channel" in msg:
            return None
        # Otherwise, try fallbacks

    # 2) Some builds expose a generic read("lidar")/("lidar_scan")
    for ch in ("lidar", "LIDAR", "lidar_scan", "scan"):
        if hasattr(bot, "read"):
            try:
                scan = bot.read(ch)
                if scan is None:
                    continue
                if isinstance(scan, dict):
                    ranges = scan.get('range') or scan.get('ranges')
                    thetas = scan.get('angle') or scan.get('angles')
                    return ranges, thetas
                else:
                    return scan
            except Exception as e:
                if "no data on channel" in str(e).lower():
                    return None
                # keep trying others
                continue

    # Nothing worked this tick
    return None

def safe_set_vel(bot, linear, angular):
    """
    Use set_vel if it exists; otherwise try drive(...) or motors(...).
    """
    if hasattr(bot, "set_vel"):
        try:
            bot.set_vel(float(linear), float(angular))
            return
        except Exception:
            pass

    if hasattr(bot, "drive"):
        try:
            sig = inspect.signature(bot.drive)
            n = len(sig.parameters)
            if n >= 3:               # drive(vx, vy, wz)
                bot.drive(float(linear), 0.0, float(angular))
                return
            elif n == 2:             # drive(vx, wz)
                bot.drive(float(linear), float(angular))
                return
        except Exception:
            pass

    if hasattr(bot, "motors"):
        try:
            # Simple diff drive approximation: same wheel speeds = straight
            bot.motors(float(linear), float(linear))
            return
        except Exception:
            pass
    # If nothing available, do nothing (but don't crash)

def safe_stop(bot):
    # Try your professor's stop() if it exists; else just zero velocity.
    if hasattr(bot, "stop"):
        try:
            bot.stop()
            return
        except Exception:
            pass
    safe_set_vel(bot, 0.0, 0.0)

# --------------------------------------------------------------------

# Initialize a robot object.
robot = MBot()
setpoint = 1.0  # Target distance to maintain from wall (in meters)

# Controller parameters
Kp = 2.0       # Proportional gain - how aggressively to respond to error
max_speed = 0.5  # Maximum robot speed
min_speed = 0.1  # Minimum robot speed to keep moving

try:
    # Loop forever.
    while True:
        # Read the latest Lidar scan (robustly).
        got = safe_read_lidar(robot)
        if not got:
            # No LiDAR yet: hold still briefly and retry
            safe_set_vel(robot, 0.0, 0.0)
            time.sleep(0.1)
            continue

        ranges, thetas = got

        # Get the distance to the wall in front of the robot.
        dist_to_wall = find_fwd_dist(ranges, thetas)

        # If we couldn't compute a valid distance, hold and retry
        if not np.isfinite(dist_to_wall):
            safe_set_vel(robot, 0.0, 0.0)
            time.sleep(0.1)
            continue

        # Calculate the error (difference between desired and actual distance)
        # Your comment: "If error is positive, we're too close, so move backward"
        # To match that comment, use a negative sign on the control:
        error = setpoint - dist_to_wall
        control_signal = -Kp * error   # <-- minimal fix so 'too close' => negative speed (back up)

        # Clamp the speed to reasonable limits
        speed = float(np.clip(control_signal, -max_speed, max_speed))

        # Apply minimum speed threshold to avoid getting stuck
        if abs(speed) < min_speed and abs(error) > 0.1:
            speed = min_speed if speed > 0 else -min_speed

        # Set robot velocity: Positive = forward, Negative = backward
        safe_set_vel(robot, speed, 0.0)

        # Print status for debugging
        print(f"Distance: {dist_to_wall:.2f}m, Error: {error:+.2f}m, Speed: {speed:+.2f}m/s")

        # Small delay before next scan
        time.sleep(0.1)

except KeyboardInterrupt:
    pass
except Exception as e:
    print(f"[ERROR] {e}")
finally:
    safe_stop(robot)
    print("[INFO] Stopped.")

